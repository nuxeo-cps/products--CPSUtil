========
CPS JOBS
========

:Revision: $Id: fields.txt 51533 2007-04-16 09:32:03Z gracinet $

.. sectnum::    :depth: 4
.. contents::   :depth: 4

CPS jobs is a harness to launch python scripts against a CPS
instance. These scripts can invoke any API from the Zope/CMF/CPS stack
and run as unrestricted users. It works either in monolithic or ZEO
setups (see below).

INSTALL
=======

Scripts can be lauched either through ``zopectl run`` or using a
custom alternative to zopectl, usually called ``cpsjob``.

Before running any job, you have to prepare the bootstrap launcher
from the ``zopectl`` control script. If the value of ``INSTANCE_HOME``
is the path to the Zope instance you want to equip, do the following::

   $ cd ${INSTANCE_HOME}/bin
   $ cp zopectl cpsjob
   $ patch -p0 cpsjob < Products/CPSUtil/cpsjob.patch

The ``cpsjob`` shell script has the same fundamental properties as
``zopectl``. Notably, it is *tied to the instance*. If you need it
in another Zope instance, even from the same ZEO cluster, you'll have
this small procedure again. Same if you want to relocate the instance.
The common reason for ``zopectl`` and ``cpsjob`` is that both include
the path to the instance.

INSTANCE TYPES
==============

The best flexibility is achieved with a ZEO cluster setup. In that
context, there's no need to stop the application, and a job can be ran
in any client, currently serving requests or not. There's no need to
make a dedicated client.

In monolithic setups, you have to stop the instance before running a
CPS job. This is because the running instance has a lock on the ZODB.

INVOCATION
==========

With the custom launcher
------------------------
Assuming the ``cpsjob`` of that instance is on the ``PATH``, do::

 $ cpsjob [options] <portal id> <python module> [job args]

where <portal id> is the id of the CPS portal at the root of the ZODB
hierarchy, and <python module> is the dotted name of a python module
such as ``myjob`` (from ``myjob.py`` on the current python path) or
``Products.CPSDefault.jobs.examplejob`` (standard Zope import
context).

Through ``zopectl run``
-----------------------
From the instance home::

 $ bin/zopectl run /path/to/the/script.py [options] <portal id> [job args]

where <portal id> is as above

Available options
-----------------

Do ``cpsjob --help`` for an up-to-date list of options. Currently
this is::

  -h, --help            show this help message and exit
  -u USER_ID, --username=USER_ID specifies the id of the transient
  unrestricted user to run as (will appear, e.g, in status history of
  modified documents). Defaults to 'cpsjob'.

Additional arguments
--------------------

They will be passed to the job (see below).

Testing the custom launcher
---------------------------

You can for instance use the sample script provided below.

JOB PYTHON SCRIPTS
==================

A job script for the custom launcher must declare a ``run`` function,
accepting two positional arguments::

- portal -- CPS portal object
- arguments -- further arguments for the job.

A job for ``zopectl run`` must instead do the following::

 >>> from Products.CPSUtil.cpsjob import bootstrap
 >>> portal, options, arguments = bootstrap()

Otherwise, they follow the same rules as any piece of unrestricted
code. You can do anything that does not expect the REQUEST object to
be a real one (see below), and import any module from Zope or the
 application code.

The configuration is mostly read from the standard ``zope.conf`` file.

Persisting changes
------------------

Unlike External Methods, or code running in the context of an HTTP
request, a CPS job has to invoke itself the transaction commit,
otherwise nothing will be persisted::

  >>> import transaction
  >>> transaction.commit()

This is really the same as within a ``zopectl debug`` session.

Job arguments
-------------
In the custom launcher context, the standard ``sys.argv`` will be
empty once the job code is reached. This is required by the Zope
starter.

In the ``zopectl run`` context, this is true after the call to ``bootstrap``.

In particular, in order to use the ``optparse``
standard module, the job has to pass ``arguments``
explicitely to the ``OptionParser`` instance, like this::

  >>> parser.parse_args(args=arguments)

Another possibility, in the ``zopectl run`` context is to add options
to ``cpsjob.optparser`` before the call to ``bootstrap``.
The user would have to be entered before the portal id. The call to
``bootstrap`` does the parsing::

 >>> portal, options, arguments = bootstrap()

arguments stores the arguments after the portal id (same as in custom
launcher context)

Sample job
----------

This job prints the creation date of the portal, or of a document specified by
its relative path from the portal::

  from zope.interface import implements
  from Products.CPSCore.interfaces import ICPSProxy, ICPSSite

  def run(portal, args):
      rpath = args and args[0] or ''
      ob = portal.unrestrictedTraverse(rpath)

      if ICPSSite.providedBy(ob):
	  print "Found the portal object"
      elif not ICPSProxy.providedBy(ob):
          raise RuntimeError("Object at '%s' is not a CPS Proxy." %
	  rpath)
      else:
          print "\nFound CPS proxy at '%s'" % rpath

      print "Creation date: %s" % ob.created() # Dublin core API

It can be enabled for ``zopectl run`` by further adding this::

  if __name__ == '__main__':
      from Products.CPSUtil.cpsjob import bootstrap
      portal, options, arguments = bootstrap(app)
      run(portal, arguments)

Of course, if the goal is to support just one of the invocations
methods, there's no need for such an indirection.

.. Emacs
.. Local Variables:
.. mode: rst
.. End:
.. Vim
.. vim: set filetype=rst:
